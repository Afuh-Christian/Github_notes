# 00:17:00

# 
A(Project directory)        


B(Staging Area or Index)
- Git has a special intermediate steps that doesn't exist in most other version control systems   
- It's what proposes for the next commit or next snapshot
- Allows us to review our work before  recording a snapshot

C
(Git Repository)
(which is actually a hidden subdirectory in our project directory )


 # Process ... 
 - Everyday as we work on A , we modify task
 - Add modified A to B(review changes and if everything is good)
 - Then make a commit or snapshot and send to C
 - The proposed snapshot will get permanently stored in our repository

# NB ... 
- In B .. if some of the changes(in A) shouldn't be recorded as  a snapshot
    - We can unstage them and commit them as part of another snapshot

                                            



# EXAMPLE  

A 
- file1
- file2 


B 
>git add file1 file2 
- file1
- file2 


C
>git commit -m  "initial commit"
- file1
- file2 



# NB "initial commit" ... this message indicates what the snapshot represents 
 - Each commit name represents the state of a project at a particular point in time 

# NB .. a common misconception about git 
- once we commit , B becomes empty
    - this is not correct ... people get confused with this 
    - What you currently have in the staging area (B) 
        - thesame snapshots that were stored in the repository

- So this staging area is actually very similar to a staging environment you use when releasing software to production. 
    - It's either a reflection of what you currently have in production  or the next version that will go in production


# EXAMPLE CONTINUATION 

# if we alter file1 and we need to stage it alone 

A 
- file1  . edited 
- file2   

B (staging area)
>git add file1 


C (Repository)
> git commit -m "Fixed the bug" 


# Now we have a different name for our commit just to indicate what we just did 


# If we no longer need file2  
- delete from A 

A 
- file1

B 
>git add file2  

C 
> git commit -m "Removed unused code"  


# Even though we are deleting the file2 ,,, we still use the "git add file2" because git will notice file2 does not exist in A and will now just delete from the staging area B



# Now we have 3 commits in our remository
- "initial commit"
- "Fixed the bug" 
- "Removed unused code"

# Each commit contains a unique ID generated by git
# Each commit also contain info about what was changed by who , when , and a complete snapshot of our project 

# COMMIT 
- ID 
- Message 
- Date/Time 
- Author 
- Complete snapshot 

# NB unlike many version controll systems , 
- git doesn't store the del task ( what was changed)
- git stores the full content
    - with this , it can quickly restore the project to an earlier snapshot without having to compute the changes

- git is very efficient in data storage 
    - It compresses the content 
    - Doesn't store duplicate content



# what to know is that 
- Each commit contains a complete snapshot of our project and this allows us to quickly get back to a previous state


